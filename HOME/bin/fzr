#!/usr/bin/env python3
# idea from: https://github.com/DanielFGray/fzf-scripts/blob/master/fzrepl
import argparse
import sys
from pathlib import Path
from subprocess import PIPE, run
from tempfile import NamedTemporaryFile

HISTORY_PATH = Path.home() / '.config/fzr/history'

def get_fzr_cmd(cmd, temp_path):
    if '{}' not in cmd:
        cmd += ' {}'

    cmd = cmd.replace('{}', '{q}')
    return [
        'fzf',
        '--sync',
        '--ansi',
        '--read0',
        '--no-info',
        '--disabled',
        '--height=100%',
        '--print-query',
        '--header', cmd,
        '--history', HISTORY_PATH,
        '--preview', f"{cmd} <{temp_path}",
        '--preview-window=down,99%',
        '--bind=ctrl-r:refresh-preview',
        '--bind=up:previous-history,down:next-history',
        '--bind=alt-left:backward-word,alt-right:forward-word',
        f'--bind=ctrl-t:execute-silent({cmd} <{temp_path} | code -)',
    ]


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Interactive fzf repl")
    parser.add_argument('command')
    args = parser.parse_args()

    if not HISTORY_PATH.exists():
        HISTORY_PATH.parent.mkdir(exist_ok=True)

    with NamedTemporaryFile('w') as tmp:
        cmd = get_fzr_cmd(args.command, tmp.name)
        tmp.write(sys.stdin.read())
        tmp.seek(0)
        result = run(cmd, stdin=tmp, stdout=PIPE, text=True)
        if not result.returncode:
            # upon accepted query, print it (first line)
            print(args.command, repr(result.stdout.splitlines()[0]))

            # remove adjacent duplicates in the history file
            run(f'echo "$(uniq {HISTORY_PATH})" > {HISTORY_PATH}', shell=True)
        elif result.returncode == 130:
            pass
        else:
            print(f"{result.stdout=}")
            # can't PIPE stderr because fzf uses that for output
            sys.exit(result.returncode)
