#!/usr/bin/env python3
# kw = "kitty window"
# open a new kitty window with the provided command
import argparse
import functools
import json
import os
import subprocess
import sys
import tempfile
import threading

TAIL = 'gtail'  # gnu tail


def find_window_pid(kitty_ls_windows, id):
    for os_window in kitty_ls_windows:
        for tab in os_window['tabs']:
            for window in tab['windows']:
                if window['id'] == id:
                    return window['pid']


def send_stdin_to_named_pipe(path):
    with open(path, 'w') as file:
        try:
            file.writelines(sys.stdin.readlines())
            file.flush()
        except BrokenPipeError:
            return


def wait_for_window_exit(window_id):
    ls = json.loads(run(['kitty', '@', 'ls']).stdout)
    pid = find_window_pid(ls, window_id)
    # https://stackoverflow.com/a/41613532
    subprocess.run([TAIL, '--pid', str(pid), '-f', '/dev/null'])


def kitty_launch(subcmd, wait: bool, launch_args={}):
    cmd = ['kitty', '@', 'launch', '--cwd', 'current', '--copy-env']
    for k, v in launch_args.items():
        cmd += [f'--{k}', v]
    cmd += ['--', *subcmd]
    result = run(cmd)
    if wait:
        window_id = int(result.stdout)
        wait_for_window_exit(window_id)


def get_additional_launch_args(args):
    kwargs = {}
    if args.vertical:
        kwargs['location'] = 'vsplit'
    elif args.horizontal:
        kwargs['location'] = 'hsplit'
    elif args.new:
        kwargs['type'] = 'os-window'
    elif args.cwd:
        kwargs['type'] = 'cwd'
    return kwargs


def main(args, rest):
    launch_args = get_additional_launch_args(args)

    if sys.stdin.isatty():
        return kitty_launch([args.program, *rest], args.wait, launch_args)

    # if pipeline, pass stdin to subprocess via named pipe
    temp_dir = tempfile.mkdtemp()
    path = os.path.join(temp_dir, 'fifo')
    try:
        os.mkfifo(path)
        cmd = ['sh', '-c', f"cat {path} | {args.program} {' '.join(rest)}"]
        t1 = threading.Thread(target=kitty_launch, args=[cmd, args.wait, launch_args])
        t1.start()
        send_stdin_to_named_pipe(path)
        t1.join()
    finally:
        os.unlink(path)
        os.rmdir(temp_dir)


run = functools.partial(subprocess.run, capture_output=True, check=True)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Open a kitty window with the provided command")
    parser.add_argument("program", help="Program to execute")
    parser.add_argument("-w", "--wait", action="store_true", help="Wait for completion of the subcommand before returning")
    parser.add_argument("-d", "--dir", help="Execute program in directory")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("-H", "--horizontal", action="store_true", help="Split window horizontally")
    group.add_argument("-v", "--vertical", action="store_true", help="Split window vertically")
    group.add_argument("-n", "--new", action="store_true", help="Open into new kitty os window")
    group.add_argument("-t", "--tab", action="store_true", help="Open into new kitty tab")

    args, rest = parser.parse_known_args()

    sys.exit(main(args, rest))

# to implmement:
# - kw --cwd [command] open command in dir that looks for an existing tab (or any window) at that dir and switches to that if a command is not currently running and runs the command in it.
#   if there's no window existing I'll create a new TAB.
#   MAYBE provide an -e --existing option to prefer an existing window
# - configure vscode tasks to be able to run things by calling kw --dir {} cmd.
